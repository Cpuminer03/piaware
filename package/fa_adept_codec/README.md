# fa_adept_codec packages

These packages handle encoding/decoding of a more compact form of the TSV data emitted by faup1090. The compact form is what is sent over the network, and it is reexpanded on the server side.

## Packages defined here

There are a few packages defined:

 * fa_adept_codec: codec registry; doesn't actually define any codecs
 * fa_adept_schema: codec builder used to generate 2.0+ codecs from a DSL description
 * fa_adept_codecs: a package containing the actual codecs, defined across several `.codec` files, one file per codec version

## Getting a codec instance

```
package require fa_adept_codecs

set codec [::fa_adept_codec::new adept $version] ;# get the latest adept codec
# or
set codec [::fa_adept_codec::new adept $version] ;# get a specific adept codec
# or
set codec [::fa_adept_codec::new none] ;# get the no-op codec
```

## Methods on codecs

```
# get the codec version
$codec version
# encode/compress the array `row` in place
$codec encode row
# decode/decompress the array `row` in place
$codec decode row
```

## Schema DSL

`fa_adept_schema` provides a mini-DSL that allows simple definition of codecs. By convention, the definitions live in a `.schema` file.

### Boilerplate

Use `::fa_adept_schema::define` to define a new codec:

```
package require fa_adept_schema
::fa_adept_schema::define adept 2.0 {
   # DSL contents here
}
```

The DSL is actually just a tcl script with some procs predefined.

### Numeric fields

```
  unsigned N/M fieldName
  # or
  signed N/M fieldName
```

This declares `fieldName` with up to N decimal digits left of the decimal point and up to M decimal digits right of the decimal point. For example:

 * `unsigned 3/0 fieldname` can represent values between 0 and 999 inclusive
 * `signed 1/3 fieldname` can represent values between -9.999 and 9.999 inclusive

### Fixed-length hex fields

```
  hexdigits 6 fieldName
```

This declares `fieldName` as having exactly 6 hex digits.

### Enumerated fields

```
  enum { a b c d } enumField
```

This declares `enumField` as a field that can take one of four values: `a`,
`b`, `c`, or `d`.

### Flags fields

```
  flags { a b c d } flagsField
```

This declares `flagsField` as a field that is a set of zero or more values chosen from `a`,`b`, `c`, or `d`; duplicated values are ignored.

### Epoch times

```
  epoch epochField
```

This is a shorthand for declaring an unsigned numeric field suitable for storing a clock epoch value.

### Single-purpose types

```
  identstring identField
```

This declares `identField` as an 8-character string with whitespace trimmed.

```
  position positionField
```

This declares `positionField` as a position type where the value is a 4 element list containing latitude, longitude, NIC value, Rc value.

### Metadata and meta_source_enum

By default, each field is expected to include source and age metadata as well as a value; the format is a three element list:

```
  set row(field) [list $value $age $source]
```

`value` is the actual data value, of the type declared for the field.
`age` is the age of the data, in seconds.
`source` is an enumerated value indicating the data source (e.g. ADS-B versus TIS-B).

The enumeration values used for `source` are defined by a `meta_source_enum` definition:

```
  meta_source_enum {U S A T}      ;# (U)nchecked-modes, mode(S), (A)dsb, (T)isb
```

Optionally, fields can omit this metadata. To declare this, pass `-nometa` as the final argument of the field definition.

## General encoding rules

For codecs generated by `fa_adept_schema`, the general encoding rules work like this:

 * There is a special array entry with key `!`, that holds the encoded data
 * The start of the `!` value is a header that has a bitfield indicating which fields are actually present in the encoded data.
 * Following the header are the encoded fields, in the same order as in the header bitfield.
 * All encoded fields are fixed length.
 * If a field can be encoded, it is added to `!` and the unencoded value is removed from the array.
 * If a field can't be encoded (e.g. badly formatted or not a known field) then it is left unchanged in the array and not added to `!`.

## Notes for FlightAware developers

This package is also used by fa_adept for the decode side. If the schema needs to change, create a new copy with a new version number so the server can continue to handle older clients correctly.

This code needs to stay tcl8.5-compatible for piaware on wheezy
